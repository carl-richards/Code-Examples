From: Ross Montgomery
Sent: 02 November 2011 18:07
To: Girish Patel; Carl Richards; Jon Simmonds; Jonathan Whitby; Victoria Gilmour; Rajiv Kumar; Ashok Nautiyal; Dave Clifford; Sarah Abbott; Kevin Abbott; Nerissa Lebrun
Subject: A small note on 'bulk bind' improvements in 11g

Hi All,

 

Here’s a small point that I was hoping would be covered in the 11g Advanced PLSQL course. I’m mentioning it because it relates to something that has always irritated me about bulk binding in 10g and below (please correct me if I’m wrong about this), so I’m hoping that you will also benefit from knowing about an apparent improvement in 11g.

 

Try the following in 10g:

 

First, set up a simple test table:

 

create table ross_temp (my_number number(1) primary key, my_string varchar2(30));

 

insert into ross_temp values (1,'string one');

insert into ross_temp values (2,'string two');

insert into ross_temp values (3,'string three');

insert into ross_temp values (4,'string four');

insert into ross_temp values (5,'string five');

insert into ross_temp values (6,'string six');

insert into ross_temp values (7,'string seven');

insert into ross_temp values (8,'string eight');

 

select * from ross_temp;

 

Now, try running the following code. It doesn’t do much, but it attempts to bulk bind a ‘record type’ collection into a forall statement:

 

declare

       type tab is table of ross_temp%rowtype;

    

       my_table tab;

begin

       dbms_output.enable(null);

    

       select my_number, upper (my_string) 

       bulk collect into my_table

       from ross_temp;

 

forall i in indices of my_table

              update ross_temp

              set my_string = my_table(i).my_string

              where my_number = my_table(i).my_number;

 

end;

 

As I understand it, this will fail in 10g: “implementation restriction: cannot reference fields of BULK In-BIND table of records”. Basically, it doesn’t like the fact that I’m referencing individual attributes (my_string, my_number) of the my_table collection in the forall statement. This is very annoying, because intuitively this is exactly the way that you want to do a bulk-bind.

 

Instead, in 10g, you have to split all of the attributes of your record type into separate collections:

 

declare

       type tab_n is table of ross_temp.my_number%type;

       type tab_s is table of ross_temp.my_string%type;

    

       my_table_n tab_n;

       my_table_s tab_s;

begin

       dbms_output.enable(null);

    

       select my_number, upper (my_string) 

       bulk collect into my_table_n, my_table_s

       from ross_temp;

 

       forall i in indices of my_table_n

              update ross_temp

              set my_string = my_table_s(i)

              where my_number = my_table_n(i);

 

end;

 

I’m told (I haven’t tried this – probably should have done so during the Exercises…) that ORACLE has finally removed the above restriction in 11g, so if you try the first example against an 11g database, I think it should work. J

 

 

And finally, because I couldn’t resist: 

 

For the Java programmers, just in case you weren’t aware: you CAN create ‘variable’-width multidimensional arrays in Java:

 

The following class

 

public class Test {

       

       public static void main(String[] args) {

              

              int[][] arr1 = new int[3][3];     // OK, this works

              

              arr1[1][2] = 1;

              

              int[][] arr = new int[3][];                     // But so does this!

              

              arr[0] = new int[]{1,2};

              arr[1] = new int[]{3,4,5,6,7,8,9,};

              arr[2] = new int[]{10,11,12,13,14};

              

              System.out.println("'Regular' 2-d array:");

              for(int i=0; i<arr1.length; i++) {

                     for(int j=0; j<arr1[i].length; j++) {

                           System.out.print("|  " + arr1[i][j] + ((j == arr1[i].length - 1) ? " |" : " "));

                     }

                     System.out.println("\n");

              }

              

              System.out.println("'Variable' 2-d array:");

              for(int i=0; i<arr.length; i++) {

                     for(int j=0; j<arr[i].length; j++) {

                           System.out.print("|  " + arr[i][j] + ((j == arr[i].length - 1) ? "   |" : " "));

                     }

                     System.out.println("\n");

              }

       }

}

 

produces the following output:

 

'Regular' 2-d array:

|      0      |      0      |      0      |

 

|      0      |      0      |      1      |

 

|      0      |      0      |      0      |

 

'Variable' 2-d array:

|      1      |      2      |

 

|      3      |      4      |      5      |      6      |      7      |      8      |      9      |

 

|      10     |      11     |      12     |      13     |      14     |

 

 

Regards,

 

Ross Montgomery

Systems Designer

Simplyhealth

Anton House, Chantry Street, Andover, Hants, SP10 1DE

t: 01264 342624

e: ross.montgomery@simplyhealth.co.uk

w: simplyhealth.co.uk

 
